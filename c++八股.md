## C++多态与虚指针

目的：允许基类的指针或引用调用继承类中定义的虚函数方法, 同时指名可以override的成员函数（提高程序的可读性）

example：
```c++
class Base {
public:
    virtual void display() {
        cout << "Base display" << endl;
    }
};
 
class Derived : public Base {
public:
    virtual void display() override {
        cout << "Derived display" << endl;
    }
};
 
int main() {
    Base *ptr = new Derived();
    ptr->display();  // 输出 "Derived display"
    return 0;
}
```

* `虚函数`：即被virtual修饰的类成员函数
* `隐藏(重定义)`与`覆盖(重写)`的区别：
  * 隐藏的基类函数没有 virtual 修饰，而覆盖的基类函数有 virtual 修饰
  * 隐藏（重定义）的直接效果：如果用一个父类的指针（或引用）指向（或引用）子类对象，那么这个父类的指针或引用将调用父类的同名函数；而不是多态下期望的子类方法。
* `override` 和 `final`: C++11 增加的两个继承控制关键字：
  * override 类似 `@override` in java, 保证在派生类中声明的重载函数，与基类的虚函数有相同的签名
  * final：在类名后加上 final 关键字，阻止类被进一步继承；在虚函数后加上 final 关键字，组织虚函数被进一步重写
* `纯虚函数`: 是一个没有实现的虚函数，它在基类中声明为virtual void func() = 0;。含有纯虚函数的类不能实例化，只能作为抽象基类使用，规范了派生类必须重写。
  ```C++
    class Shape {
    public:
        virtual double getArea() = 0; // 纯虚函数
    };
  ```


## C++中的友元

* `友元函数`是在一个类中声明的一个非成员函数，但在类的内部声明该函数为友元。这意味着该函数可以访问该类的私有成员和保护成员，包括私有变量和私有函数。
* `友元函数`的声明通常位于类的声明中，但其实现则位于类外部。
* `友元类`的声明使得一个类可以访问另一个类的私有和受保护成员。‌但友元关系是单向的，不具有交换性
* 友元关系不能传递
* 当需要重载类的操作符（如<<、>>、+、-等）时，友元函数可以访问私有成员，实现合适的操作。

友元函数example:

```c++
class People {
    string name;
    int age;
    // 友元函数，用于改变私有数据成员的值
    friend void grow(People& p);
public:
    // 构造函数
    People(string name, int age): name(std::move(name)), age(age) {}
    // 获取年龄
    int getAge() const {
        return age;
    }
};
 
// 实现友元函数，用于改变私有数据成员的值
void grow(People& p) {
    ++p.age;
}
 
int main() {
    People p{"Asuna", 17};
    std::cout << "origin age: " << p.getAge() << std::endl; // 输出原始年龄 17
    // 使用友元函数修改
    grow(p);
    // 输出修改后的年龄
    std::cout << "now age: " << p.getAge() << std::endl; //输出改变后的年龄 18
    return 0;
}
```

友元类example:

```c++
class Student {
    // 声明 StudentCaculate 类是 Student 类的友元类
    // 在 StudentCaculate 类中可以访问 Student 类中的私有成员
    friend class StudentCaculate;
private:
    int score; // 假设有一个私有成员变量 score
};

class StudentCaculate {
public:
    void calculateScore(Student s) {
        // 在这里可以访问 Student 类的私有成员变量 score
        s.score = 100; // 这是一个友元操作，‌因为 StudentCaculate 类是 Student 类的友元
    }
};
```

## C++建议 const enum inline去替代宏

C++中`inline`来替代C中的`宏函数`;
`const`、`enum`替代C中的`宏常量`

### 宏函数的优缺点：

* 优点（同inline）：
  * 宏（内联）函数在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
  * 当频繁调用一个函数的时候（比如快排算法中函数多次被调用），此时消耗栈帧的比较大（不断地调用栈帧销毁栈帧）。此时使用内联或宏函数会带来优化。
* 缺点：
  * 1、不能调试（因为预编译阶段进行了替换）
  * 2、没有类型安全的检查
  * 3、有些场景下非常复杂，容易出错，不容易掌握:
    * 不能加分号$\{\}$, 宏是把东西都替换掉，如果定义带了分号，那么替换后的语句将会有两个分号
    * 返回值需要有外部括号，防止优先级错误
    * 输入值需要有内部括号，防止优先级错误

    例子：正确的ADD宏函数：

    ```c++
    // 宏函数
    #define ADD(x, y) ((x) + (y));
    ```

### 内联函数替代宏函数:

在函数返回值前加一个inline即可， 那么函数就会在调用位置直接展开

```c++
// 内联函数
inline int Add(int a,int b)
{
    return a + b;
}
```

优点：

* 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
* 内联函数在运行时可调试
* 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量

```c++
// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```

缺点：

* 可执行文件大小增大。
（inline是经典的空间换时间，在使用内联函数时，是将代码展开，而不是到内存栈中寻找函数的位置，容易造成代码膨胀）（例如N次使用函数时，且函数为K行代码，普通函数使用时用了N+K行，而内联函数使用时用了N*K行）
* 内联函数最适合用于小型函数，例如提供数据成员访问权限的函数。 短函数对函数调用的开销很敏感。 较长的函数在调用和返回序列方面花费的时间可成比例地减少，而从内联的获益也会减少。

### const代替宏常量

```c++
// 使用宏定义常量
#define PI 3.14159265358979323846
// 使用const定义常量
const double PI = 3.14159265358979323846
```

使用const代替宏，使得常量具有明确的数据类型，有助于编译器进行类型检查；同时有利于发生错误时的DEBUG，当使用宏常量但得一个编译错误信息时，有可能会带来困惑，因为这个错误会提到 3.14159265358979323846 而不是 PI。

### 枚举enum

* **特点**：
  * 枚举可以一次定义大量相关的常量，枚举可以自增，这样不用每一个值都定义
  * 枚举是一个集合，代表一类值，方便使用

* 枚举类型的基础类型必须是整型，C++11之后可以是 `int`、`unsigned int`、`char` 或者其他整型变体。默认情况下，如果不指定基础类型，枚举会使用 int 作为其底层类型。


```c++
enum COLOR : unsigned int
{
	RED, // 0
	ORANGE, // 1
	YELLOW, // 2
	GREEN = 10,
	CYAN, // 11
	BLUE, // 12
	PURPLE, // 13
};
```

可以使用类中的枚举常量来建立在整个类中都恒定的常量：

```c++
class Person{
public:
    using SexType = enum : long long{
        BOY = 0,
        GIRL // 显性 longlong 所以 sizeof(Person::BOY) == 8.
    };
};
//访问的时候通过，Person::BOY或者Person::GIRL来进行访问。
```

## 智能指针

|智能指针|类型|
|:--:|:--:|
|`shared_ptr`|共享指针，多个共享指针可以指向同一个对象|
|`weak_ptr`|该指针是对象的一个非拥有性引用，指向一个shared_ptr，主要用来避免shared_ptr环形依赖|
|`unique_ptr`|该指针独占对象的所有权，每个对象智能有一个该指针|

**shared_ptr**:

* 智能指针内部有一个计数器，当赋值给别的智能指针或者函数传参拷贝到另一个shared_ptr，计数器就会加1，当函数执行完毕，智能指针对象 就被析构了，此时计数器就会减一，知道计数器变为0 ，说明没人在用这个对象了，就执行delete把它释放掉。
* 线程不安全，读安全，写不安全，要加锁保证线程安全

```C++
p = make_shared<Objcet>(Objcet);//此为推荐方式
auto p2 = p; // 复制指针
cout << p.use_count() << endl; // use_count()，得到当前有多少个指针指向该对象
Objcet* rp = p.get()    // get()，获得裸指针, 尽可能避免裸指针和共享指针同时使用, 共享指针释放后裸指针变成未定义
```

**weak_ptr**：

* 环形依赖：两个或多个对象相互持有对方的智能指针（通常是shared_ptr）时，它们之间的引用计数将永远无法降到零，引发内存泄漏；通过使用weak_ptr代替其中一个或多个shared_ptr，可以打破这种循环引用，确保对象在不再需要时能够被正确销毁。
* week_ptr本身依赖shared_ptr存在,存储一个资源的引用但不能修改，只能告知资源是否存在
  
```C++
auto sp = make_shared<int>(100);
wp = sp;
auto resource = wp.lock(); // lock()，返回shared_ptr地址指针，若对象已被释放，则返回nullptr
if (resource) {
    cout << "Number is" << *resource << endl;
} else {
    cout << "wp is expired" << endl;
}
```

**unique_ptr**

* unique_ptr是独享的，不可以两个unique_ptr同时指向同一份资源
* 由于独占资源控制权，所以不支持普通拷贝，但可以转移控制权

```C++
auto up1 = make_unique<int>(100);
auto up2(up1.release());//方式1：转移控制权
auto up3 = std::move(up1);//方式2：转移控制权
```

## C++的四大特性

与 Java 类似

### 一.封装

C++中有三种权限：**public**、**protected** 和 **private**
未指定可见性模式时，**struct中默认为public模式**，**class中默认为private模式**。

public成员完全公开，可以被**所有**地方访问
private成员**仅限类内部**访问，外部和派生类都无法访问，或**友元函数**访问。
protected成员在**类内部和派生类**中可访问，在类外部不可访问。

### 二.继承

有三种继承，分别是公有继承(public)，保护继承（protected）和 私有继承（private）

**公有继承（public）:**

* 公有继承的规则是“**is-a**”关系，即子类是基类的一种。
* 基类的公有成员在子类中保持公有属性。
* 基类的保护成员在子类中保持保护属性。
* 基类的**私有成员不可被继承**，因此在子类中不可见。
* 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。
* 通过派生类的对象访问从基类继承的成员，只能访问public成员。

**保护继承（protected）:**

* 保护继承通常用于实现“**is-implemented-in terms of**”关系。
* 基类的**公有成员和保护成员在子类中都变为保护属性**。
* 基类的**私有成员不可被继承**，因此在子类中不可见。
* 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。
* 通过派生类的对象不能直接访问从基类继承的任何成员。

**私有继承（private）:**

* 私有继承用于实现“**uses-a**”关系，即子类使用基类来实现某些功能，但不是基类的一种。
* 基类的公有成员和保护成员在子类中都变为私有属性。
* 基类的私有成员不可被继承，因此在子类中不可见。
* 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。
* 通过派生类的对象不能直接访问从基类继承的任何成员


### 三.多态

**在继承中要构成多态还有两个条件 :**

必须通过**基类的指针**或者**引用调用虚函数**
被调用的函数必须是**虚函数**，且派生类必须对基类的虚函数进行**重写**


注意：

* 对不是虚函数的函数进行重写是**重定义**
* 在重写基类虚函数时，派生类的虚函数在不加virtual关键字时，虽然也可以构成重写(因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性)，但是该种写法不是很规范，不建议这样使用
* 析构函数非常建议写成虚函数

### 四.抽象

抽象通常通过**抽象类**或**接口**实现。

在C++中，**用纯虚函数来定义接口抽象类，不能实例化**，只能通过继承并实现其纯虚函数来创建具体的类，派生类必须实现这些函数才能创建对象。


## C++ static关键字

Static关键字用于声明变量或函数的**存储期为整个程序的执行期间**，即使它们的作用域是局部的。

### 静态全局变量

在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。

```C++
static int n; //定义静态全局变量
```

**静态全局变量与全局变量：**

相同：

* 二者都存储在**静态区（数据区）**
* 二者都在程序**开始执行时创建**，**在程序结束时销毁**。
* 未经初始化的**函数体外的变量**（二者都是），会被程序自动**初始化为 0**（隐式转换为该类型）

区别：

* 全局变量是**所有程序都可见**的变量，在一个文件内定义的全局变量，在另一个文件中，通过 **extern** 全局变量名的声明，就可以使用全局变量。

注：如果需要在多个源文件中使用相同的全局变量，可以在头文件中使用extern关键字声明全局变量，然后在一个源文件中定义它。这样，包含该头文件的其他源文件就可以访问这个全局变量。如果在未声明extern或直接在.h文件中定义了该全局变量，在多个源文件中引入头文件的情况下则会出现重定义ORD错误.

```C++
// global_variables.h
extern int globalVar;  // 声明全局变量
// extern int globalVar = 10 // 错误，不因在头文件定义
// int globalVar //错误，未声明extern

// global_variables.cpp
int globalVar = 42;  // 定义全局变量

// 其他文件只需包含头文件即可使用全局变量，而不会引起重复定义错误, 也不要重复定义。
```

* 静态全局变量的作用域是**声明此变量所在的文件**，其他的文件即使用 extern 声明也不能使用。其它文件中可以定义相同名字的变量，不会发生冲突，减少了全局命名空间的污染。考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）

### 静态局部变量

在函数中的局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。 

```C++
void count_calls() {    
    static int call_count = 0;    
    call_count++;    
    std::cout << call_count << std::endl;
}
```

**静态局部变量与局部变量：**

相同：

* 二者**作用域都是局部**的，当定义它的函数或语句块结束时，其作用域随之结束, **其他位置无法访问。**

区别：

* **静态局部变量**存储在**静态区（数据区）**
* **局部变量**存储在**栈**，
* **静态局部变量只允许初始化一次**，静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
* **局部变量**每当程序运行到该语句时都会给该局部变量**分配栈内存**。但随着程序退出函数体，系统就会**收回栈内存**，局部变量也相应失效
* **静态局部变量**一般在声明处初始化，如果没有显式初始化，会被程序**自动初始化为 0**；
* **局部变量**未初始化则是分配内存上未消除这块内存上的值，有的编译器会**报错**。

### 静态函数

在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它**只能在声明它的文件当中可见**，不能被其它文件使用。**常用于在模块内部实现辅助函数**

```C++
static void helper_function() {
    // 辅助函数实现
}
void public_function() {
    // 公共函数实现
    helper_function();
}
```

### 类中的static关键字(面向对象)



