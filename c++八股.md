## C++多态与虚函数

目的：允许基类的指针或引用调用继承类中定义的虚函数方法, 同时指名可以override的成员函数（提高程序的可读性）

example：
```c++
class Base {
public:
    virtual void display() {
        cout << "Base display" << endl;
    }
};
 
class Derived : public Base {
public:
    virtual void display() override {
        cout << "Derived display" << endl;
    }
};
 
int main() {
    std::shared_ptr<Base> ptr = std::make_shared<Derived>();
    ptr->display();  // 输出 "Derived display"

    Derived d {};
    Base& base = d;
    d.display(); // // 输出 "Derived display"
    return 0;
}
```

* `虚函数`：即被virtual修饰的类成员函数
* `隐藏(重定义)`与`覆盖(重写)`的区别：
  * 隐藏的基类函数没有 virtual 修饰，而覆盖的基类函数有 virtual 修饰
  * 隐藏（重定义）的直接效果：如果用一个父类的指针（或引用）指向（或引用）子类对象，那么这个父类的指针或引用将调用父类的同名函数；而不是多态下期望的子类方法。
* `override` 和 `final`: C++11 增加的两个继承控制关键字：
  * override 类似 `@override` in java, 保证在派生类中声明的重载函数，与基类的虚函数有相同的签名
  * final：在类名后加上 final 关键字，阻止类被进一步继承；在虚函数后加上 final 关键字，组织虚函数被进一步重写
* `纯虚函数`: 是一个没有实现的虚函数，它在基类中声明为virtual void func() = 0;。含有纯虚函数的类不能实例化，只能作为抽象基类使用，规范了派生类必须重写。
  ```C++
    class Shape {
    public:
        virtual double getArea() = 0; // 纯虚函数
    };
  ```

## C++ 虚函数表

1、C++ **VTable (虚函数表)** 是C++ 实现**多态**的方式。

2、每一个**具有虚函数**（使用virtual关键字定义的函数）**的类**的具体实现，**都有一个指向虚函数表的指针（*vptr）**。

3、指向虚函数表的指针是作为数据成员存在于所有对象中。**当调用虚函数时**，查找对象的**虚函数表**指向**正确的派生类函数**。 虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地址，假如**子类的虚函数重写了父类的虚函数**，**则其对应在虚函数表中会把对应的虚函数替换为子类的虚函数的地址**

4、静态绑定 & 动态绑定。

对于类的**普通成员函数**使用的是**静态绑定**，发生在**编译期**。
对于类的**虚函数**发生在运行期是**动态绑定**，发生在**运行期**。
虽然**虚函数的调用**是**在运行期**才**动态确定**，但是**虚函数表的创建**是在**编译阶段**就完成构建。

注：

* **虚函数**是**与对象动态绑定**的，**必定是成员函数**，静态成员函数不可以是虚函数，因为它是以类自身的函数，与具体对象无关。
* **构造函数不能是虚函数**，**析构函数可以是虚函数**。
* 构造函数和析构函数中可以调用虚函数, 但**不建议**，**此时为**对虚函数的调用其实是**实调用**

## C++中的友元

* `友元函数`是在一个类中声明的一个非成员函数，但在类的内部声明该函数为友元。这意味着该函数可以访问该类的私有成员和保护成员，包括私有变量和私有函数。
* `友元函数`的声明通常位于类的声明中，但其实现则位于类外部。
* `友元类`的声明使得一个类可以访问另一个类的私有和受保护成员。‌但友元关系是单向的，不具有交换性
* 友元关系不能传递
* 当需要重载类的操作符（如<<、>>、+、-等）时，友元函数可以访问私有成员，实现合适的操作。

友元函数example:

```c++
class People {
    string name;
    int age;
    // 友元函数，用于改变私有数据成员的值
    friend void grow(People& p);
public:
    // 构造函数
    People(string name, int age): name(std::move(name)), age(age) {}
    // 获取年龄
    int getAge() const {
        return age;
    }
};
 
// 实现友元函数，用于改变私有数据成员的值
void grow(People& p) {
    ++p.age;
}
 
int main() {
    People p{"Asuna", 17};
    std::cout << "origin age: " << p.getAge() << std::endl; // 输出原始年龄 17
    // 使用友元函数修改
    grow(p);
    // 输出修改后的年龄
    std::cout << "now age: " << p.getAge() << std::endl; //输出改变后的年龄 18
    return 0;
}
```

友元类example:

```c++
class Student {
    // 声明 StudentCaculate 类是 Student 类的友元类
    // 在 StudentCaculate 类中可以访问 Student 类中的私有成员
    friend class StudentCaculate;
private:
    int score; // 假设有一个私有成员变量 score
};

class StudentCaculate {
public:
    void calculateScore(Student s) {
        // 在这里可以访问 Student 类的私有成员变量 score
        s.score = 100; // 这是一个友元操作，‌因为 StudentCaculate 类是 Student 类的友元
    }
};
```

## C++建议 const enum inline去替代宏

C++中`inline`来替代C中的`宏函数`;
`const`、`enum`替代C中的`宏常量`

### 宏函数的优缺点：

* 优点（同inline）：
  * 宏（内联）函数在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
  * 当频繁调用一个函数的时候（比如快排算法中函数多次被调用），此时消耗栈帧的比较大（不断地调用栈帧销毁栈帧）。此时使用内联或宏函数会带来优化。
* 缺点：
  * 1、不能调试（因为预编译阶段进行了替换）
  * 2、没有类型安全的检查
  * 3、有些场景下非常复杂，容易出错，不容易掌握:
    * 不能加分号$\{\}$, 宏是把东西都替换掉，如果定义带了分号，那么替换后的语句将会有两个分号
    * 返回值需要有外部括号，防止优先级错误
    * 输入值需要有内部括号，防止优先级错误

    例子：正确的ADD宏函数：

    ```c++
    // 宏函数
    #define ADD(x, y) ((x) + (y));
    ```

### 内联函数替代宏函数:

在函数返回值前加一个inline即可， 那么函数就会在调用位置直接展开

```c++
// 内联函数
inline int Add(int a,int b)
{
    return a + b;
}
```

优点：

* 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
* 内联函数在运行时可调试
* 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量

```c++
// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```

缺点：

* 可执行文件大小增大。
（inline是经典的空间换时间，在使用内联函数时，是将代码展开，而不是到内存栈中寻找函数的位置，容易造成代码膨胀）（例如N次使用函数时，且函数为K行代码，普通函数使用时用了N+K行，而内联函数使用时用了N*K行）
* 内联函数最适合用于小型函数，例如提供数据成员访问权限的函数。 短函数对函数调用的开销很敏感。 较长的函数在调用和返回序列方面花费的时间可成比例地减少，而从内联的获益也会减少。

### const代替宏常量

```c++
// 使用宏定义常量
#define PI 3.14159265358979323846
// 使用const定义常量
const double PI = 3.14159265358979323846
```

使用const代替宏，使得常量具有明确的数据类型，有助于编译器进行类型检查；同时有利于发生错误时的DEBUG，当使用宏常量但得一个编译错误信息时，有可能会带来困惑，因为这个错误会提到 3.14159265358979323846 而不是 PI。

### 枚举enum

* **特点**：
  * 枚举可以一次定义大量相关的常量，枚举可以自增，这样不用每一个值都定义
  * 枚举是一个集合，代表一类值，方便使用

* 枚举类型的基础类型必须是整型，C++11之后可以是 `int`、`unsigned int`、`char` 或者其他整型变体。默认情况下，如果不指定基础类型，枚举会使用 int 作为其底层类型。


```c++
enum COLOR : unsigned int
{
	RED, // 0
	ORANGE, // 1
	YELLOW, // 2
	GREEN = 10,
	CYAN, // 11
	BLUE, // 12
	PURPLE, // 13
};
```

可以使用类中的枚举常量来建立在整个类中都恒定的常量：

```c++
class Person{
public:
    using SexType = enum : long long{
        BOY = 0,
        GIRL // 显性 longlong 所以 sizeof(Person::BOY) == 8.
    };
};
//访问的时候通过，Person::BOY或者Person::GIRL来进行访问。
```

## 智能指针

|智能指针|类型|
|:--:|:--:|
|`shared_ptr`|共享指针，多个共享指针可以指向同一个对象|
|`weak_ptr`|该指针是对象的一个非拥有性引用，指向一个shared_ptr，主要用来避免shared_ptr环形依赖|
|`unique_ptr`|该指针独占对象的所有权，每个对象只能有一个该指针|

**shared_ptr**:

* 智能指针内部有一个计数器，当赋值给别的智能指针或者函数传参拷贝到另一个shared_ptr，计数器就会加1，当函数执行完毕，智能指针对象 就被析构了，此时计数器就会减一，知道计数器变为0 ，说明没人在用这个对象了，就执行delete把它释放掉。
* 线程不安全，读安全，写不安全，要加锁保证线程安全

```C++
p = make_shared<Objcet>(Objcet);//此为推荐方式
auto p2 = p; // 复制指针
cout << p.use_count() << endl; // use_count()，得到当前有多少个指针指向该对象
Objcet* rp = p.get()    // get()，获得裸指针, 尽可能避免裸指针和共享指针同时使用, 共享指针释放后裸指针变成未定义
```

**weak_ptr**：

* 环形依赖：两个或多个对象相互持有对方的智能指针（通常是shared_ptr）时，它们之间的引用计数将永远无法降到零，引发内存泄漏；通过使用weak_ptr代替其中一个或多个shared_ptr，可以打破这种循环引用，确保对象在不再需要时能够被正确销毁。
* week_ptr本身依赖shared_ptr存在,存储一个资源的引用但不能修改，只能告知资源是否存在
  
```C++
auto sp = make_shared<int>(100);
wp = sp;
auto resource = wp.lock(); // lock()，返回shared_ptr地址指针，若对象已被释放，则返回nullptr
if (resource) {
    cout << "Number is" << *resource << endl;
} else {
    cout << "wp is expired" << endl;
}
```

**unique_ptr**

* unique_ptr是独享的，不可以两个unique_ptr同时指向同一份资源
* 由于独占资源控制权，所以不支持普通拷贝，但可以转移控制权

```C++
auto up1 = make_unique<int>(100);
auto up2(up1.release());//方式1：转移控制权
auto up3 = std::move(up1);//方式2：转移控制权
```

## C++的四大特性

与 Java 类似

### 一.封装

C++中有三种权限：**public**、**protected** 和 **private**
未指定可见性模式时，**struct中默认为public模式**，**class中默认为private模式**。

public成员完全公开，可以被**所有**地方访问
private成员**仅限类内部**访问，外部和派生类都无法访问，或**友元函数**访问。
protected成员在**类内部和派生类**中可访问，在类外部不可访问。

### 二.继承

有三种继承，分别是公有继承(public)，保护继承（protected）和 私有继承（private）

**公有继承（public）:**

* 公有继承的规则是“**is-a**”关系，即子类是基类的一种。
* 基类的公有成员在子类中保持公有属性。
* 基类的保护成员在子类中保持保护属性。
* 基类的**私有成员不可被继承**，因此在子类中不可见。
* 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。
* 通过派生类的对象访问从基类继承的成员，只能访问public成员。

**保护继承（protected）:**

* 保护继承通常用于实现“**is-implemented-in terms of**”关系。
* 基类的**公有成员和保护成员在子类中都变为保护属性**。
* 基类的**私有成员不可被继承**，因此在子类中不可见。
* 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。
* 通过派生类的对象不能直接访问从基类继承的任何成员。

**私有继承（private）:**

* 私有继承用于实现“**uses-a**”关系，即子类使用基类来实现某些功能，但不是基类的一种。
* 基类的公有成员和保护成员在子类中都变为私有属性。
* 基类的私有成员不可被继承，因此在子类中不可见。
* 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。
* 通过派生类的对象不能直接访问从基类继承的任何成员


### 三.多态

**在继承中要构成多态还有两个条件 :**

必须通过**基类的指针**或者**引用调用虚函数**
被调用的函数必须是**虚函数**，且派生类必须对基类的虚函数进行**重写**


注意：

* 对不是虚函数的函数进行重写是**重定义**
* 在重写基类虚函数时，派生类的虚函数在不加virtual关键字时，虽然也可以构成重写(因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性)，但是该种写法不是很规范，不建议这样使用
* 析构函数非常建议写成虚函数

### 四.抽象

抽象通常通过**抽象类**或**接口**实现。

在C++中，**用纯虚函数来定义接口抽象类，不能实例化**，只能通过继承并实现其纯虚函数来创建具体的类，派生类必须实现这些函数才能创建对象。


## C++ static关键字

Static关键字用于声明变量或函数的**存储期为整个程序的执行期间**，即使它们的作用域是局部的。

### 静态全局变量

在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。

```C++
static int n; //定义静态全局变量
```

**静态全局变量与全局变量：**

相同：

* 二者都存储在程序地址空间的**静态区（数据区）**
* 二者都在程序**开始执行时创建**，**在程序结束时销毁**。
* 未经初始化的**函数体外的变量**（二者都是），会被程序自动**初始化为 0**（隐式转换为该类型）

区别：

* 全局变量是**所有程序都可见**的变量，在一个文件内定义的全局变量，在另一个文件中，通过 **extern** 全局变量名的声明，就可以使用全局变量。

注：如果需要在多个源文件中使用相同的全局变量，可以在头文件中使用extern关键字声明全局变量，然后在一个源文件中定义它。这样，包含该头文件的其他源文件就可以访问这个全局变量。如果在未声明extern或直接在.h文件中定义了该全局变量，在多个源文件中引入头文件的情况下则会出现重定义ORD错误.

```C++
// global_variables.h
extern int globalVar;  // 声明全局变量
// extern int globalVar = 10 // 错误，不因在头文件定义
// int globalVar //错误，未声明extern

// global_variables.cpp
int globalVar = 42;  // 定义全局变量

// 其他文件只需包含头文件即可使用全局变量，而不会引起重复定义错误, 也不要重复定义。
```

* 静态全局变量的作用域是**声明此变量所在的文件**，其他的文件即使用 extern 声明也不能使用。其它文件中可以定义相同名字的变量，不会发生冲突，减少了全局命名空间的污染。考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）

### 静态局部变量

在函数中的局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。 

```C++
void count_calls() {    
    static int call_count = 0;    
    call_count++;    
    std::cout << call_count << std::endl;
}
```

**静态局部变量与局部变量：**

相同：

* 二者**作用域都是局部**的，当定义它的函数或语句块结束时，其作用域随之结束, **其他位置无法访问。**

区别：

* **静态局部变量**存储在**静态区（数据区）**
* **局部变量**存储在**栈**，
* **静态局部变量只允许初始化一次**，静态局部变量在程序执行到该对象的声明处时被**首次初始化**，即**以后**的函数调用**不再进行初始化**；
* **局部变量**每当程序运行到该语句时都会给该局部变量**分配栈内存**。但随着程序退出函数体，系统就会**收回栈内存**，局部变量也相应失效
* **静态局部变量**一般在声明处初始化，如果没有显式初始化，会被程序**自动初始化为 0**；
* **局部变量**未初始化则是分配内存上未消除这块内存上的值，有的编译器会**抱怨**。

### 静态普通函数

在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它**只能在声明它的文件当中可见**，不能被其它文件使用。**常用于在模块内部实现辅助函数**

```C++
static void helper_function() {
    // 辅助函数实现
}
void public_function() {
    // 公共函数实现
    helper_function();
}
```

* 注：**函数**保存在地址空间的**代码区**，函数指名**代码的首地址**

### 类中的static关键字(面向对象)

#### 静态成员变量

在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。
```C++
class MyClass {  
public:  
    static int nonConstValue;  
};  
```

**与普通成员变量的区别：**

* 普通成员变量属于**类的对象实例**，**每个对象都有自己的一份拷贝**。
* 静态成员变量属于**类本身**，所有对象实例**共享**同一个静态成员变量。
* 静态成员变量在 **静态区（数据区）** 分配内存
* 普通成员变量在分配内存取决与上下文。
* 静态成员变量无需创建对象实例即可通过类名直接调用(**::**)，或者通过对象实例调用, 而 普通成员变量只能通过对象实例调用(**.**)
* 普通成员变量可在类内初始化，也可调用构造函数初始化，不显性初始化则为0。
* **C++11**以前，静态成员变量只能在**类外初始化**。但在C++11及之后的版本中，允许在**类内进行静态成员变量的初始化**，但必须使用`constexpr`修饰符来确保变量是**常量**，其值在编译时就是已知的。**注：改变常量（const_cast方法）

    ```C++
    class MyClass {  
    public:  
        static constexpr int constantValue = 42; // C++11及以后版本支持  
        static int nonConstValue;  
    };  
    
    int MyClass::nonConstValue = 0; // 类外初始化
    ```

* 普通成员变量可以在对象的构造函数中进行**类内初始化**。

#### 静态成员函数

 使用 static 关键字修饰成员函数, 就可以将普通的成员函数转为静态成员函数

 ```C++
class MyClass {
public:
    static void staticFunction() {
        // Some codes
    }
};
 ```

* 基本类似静态成员变量，属于**类本身**，**无需实例化**对象就可**访问**。
* 静态成员函数只能访问**静态成员变量**以及其他**静态成员函数**，因为其他的需要依托于对象才能存在。

**和普通成员函数的区别：**

* 一个对象实例调用普通成员函数时，可看作传入了一个**隐藏参数（this）** 类似于python中的self，因此使用**类直接调用普通成员函数会ERR**。




## c++中new和malloc的区别

* new是**操作符**，malloc一个**函数**
* 当使用new操作符分配内存并初始化对象时，需要传入的内容取决于对象的类型。如果对象是一个[基础数据类型](#c的基本数据类型)（如int、double等），则new操作符后面可以直接跟变量的类型，例如new int或new double。如果对象是一个自定义类型（如类或结构体），则new操作符后面可以跟类名，并且可以传入构造函数的参数来初始化对象。如果对象是一个数组，使用new操作符时，你需要指定数组的大小以及是否需要显式初始化每个元素。

  ```C++
    int* num1 = new int; // 未初始化
    *num1 = 10; // 自己赋值。
    int* num1 = new int(10); // 直接初始化
    delete num1; //

    Myclass* myclass = new MyClass(); // 调用默认构造函数
    Myclass* myclass = new MyClass(1,2,3); // 调用不同的构造函数
    delete myclass;

    int* arr = new int[3]; // 未初始化
    int* arr = new int[3](); // 都初始化为 0
    int* arr = new int[3] {1,2,3}; // 花括号显性初始化C++11起
    int* arr = new int[](4,5,6); // C++20后可以使用括号列表来初始化
    delete[] arr;
  ```
* malloc需要传入的是申请的内存大小，这个大小是以字节为单位的。
* new 会**自动**计算所需空间的大小**分配内存**，而且会**调用**类的**构造函数**进行**初始化**，同理**delete会调用类的析构函数**，new可以看成两个动作：1。分配内存(相当于malloc) 2。引发构造函数。
* 而malloc则须要由用户**自己计算**所需**空间大小**（`sizeof()`），**只分配内存**而**不会**进行**初始化**类成员的工作，同样free也不会调用析构函数
* malloc返回的是一个**void指针([泛型指针](#泛型指针))***，需手动进行类型转换以匹配所需的类型。这可能导致类型安全问题，如果转换错误，可能会导致未定义的行为。new操作符直接返回与所创建**对象类型匹配的指针**，无需进行类型转换。
* 当**内存分配失败时**，malloc会返回**NULL空指针**。需要对返回值进行判空处理，以确定内存是否成功分配。而new操作符在内存分配失败时，会**抛出bad_alloc异常**。

  ```C++
    class MyClass {
    public:
        MyClass() {
            std::cout << "Constructor called!" << std::endl;
        }
        ~MyClass() {
            std::cout << "Destructor called!" << std::endl;
        }
    };

    int main() {
        // Using new
        MyClass* objNew = new MyClass();  // Constructor is called
        delete objNew;                    // Destructor is called

        // Using malloc
        MyClass* objMalloc = (MyClass*)malloc(sizeof(MyClass));  // No constructor call
        if (objMalloc == nullptr) {
            std::cout << "failed to allocate" << std::endl;
            return -1;
        }
        else {
            free(objMalloc);  // No destructor call
        }
        return 0;
    }
  ```

* C++中不要显性使用malloc和free, 编译器会抱怨**C风格的内存管理**。它会对其使用发出警告，并尝试建议使用适当的 **RAII** 对象
* 在函数中调用new和malloc，**对象分配堆空间**，但**栈区指针**仍有自己的生命周期，若忘记对应的delete或free，贼会堆空间悬挂，造成**内存泄漏**。

## C++的基本数据类型

1. **布尔型(bool):**
    ```C++
    bool isTrue = true;
    bool isFalse = false;
    ```
2. **整形（int）：**
   ```C++
   int // 4字节，INT_MAX = $2^{31}-1$
   signed, unsigned //前者第一位用于表示正负
   short, long, // sizeof随操作系统会改变
   int64_t, int32_t, int16_t, int8_t // 保证确切位数
   ```
3. **浮点型(float):**
   ```C++
   float double
   ```
4. **字符型(char):**
   ```C++
    char c = 'A'; // 1字节8bit
    wchar_t wc = L'Ω';     // Wide character，用于 Unicode
    char16_t c16 = u'あ';  // 16-bit character，用于 UTF-16 编码
    char32_t c32 = U'𐍈';  // 32-bit character，用于 UTF-32 编码
   ```
5. **Void型：**
   当函数不需要返回值时或函数不允许接受参数时
   ```C++
    void func(void) {}
   ```
    void 指针可以指向任意类型的数据, 如malloc的返回值。


## C++空类默认生成的函数

```C++
//声明一个什么都没有的空类
class Empty{};
 
//C++默认会为该类生成以下六个成员
class Empty{
    Empty(); // 默认构造函数
    ~Empty(); // 默认析构函数。
    Empty(const Empty&); // 默认复制构造函数
    Empty& operator=(const Empty&); // 复制赋值运算符
    // 一对取址运算符（operator&），一个非const的，一个const的
    Empty* operator&(); // 取址运算符
    const Empty* operator&() const; // 取址运算符 const

    Empty(Empty&&) noexcept {} // 移动构造函数 (C++11 起)
    Empty& operator=(Empty&&) noexcept { return *this; } // 移动赋值运算符 (C++11 起)
};
```

### 默认构造函数

如果没有显式定义构造函数，编译器会隐式的为一个类生成一个构造函数，该默认构造函数没有实参，并且它将按照以下规则初始化类的数据成员:

* 如果**类内存在初始值，则就用它初始化成员**
* 对于**类类型**，由它们**自己的构造函数**默认初始化
* 否则, 当使用 type* a = new type 后没有括号，或 type a 后没花括号时，执行**默认初始化（Default Initialization）**, **内置类型保持未初始化（垃圾值）**

  ```C++
    class MyClass
    {
    private:
        //因为已经m_sold已经提供了初始值，所以默认构造函数会用提供的初始值初始化他们
        int m_sold = 10;
    
        //默认初始化bookNo为一个空字符串,因为这是类对象。
        std::string bookNo;

        // 内部类型，不同初始化下不同值。
        double revenue;
    };
    MyClass* m = new MyClass; // revenue 垃圾值
    MyClass m2; // revenue 垃圾值

    myclass* m3 = new MyClass(); // revenue = 0
    MyClass m4{}; // revenue = 0
  ```

  有括号时，执行**值初始化（Value Initialization）**， **内置类型进行零初始化。**

一旦我们**定义**了一些**其他构造函数**，那么除非我们自己再次定义一个默认构造函数，否则编译器将**不再**为我们**生成缺省构造函数**, 可以通过在参数列表后写上 **= default 要求编译器生成默认构造函数**。

### 默认析构函数

析构函数在对象被销毁时自动调用，用于进行资源的释放和清理操作。

注：

* **析构函数不能被重载**，因为析构函数没有参数，因此一个类只能有一个析构函数。
* **析构函数**可以（而且通常应该）是 C++ 中的**虚函数**，以**确保**为对象调用正确的析构函数，尤其是在**处理多态性**时。当通过指向基类的指针删除派生类对象时，保证**首先调用自身的析构函数**。
* **析构函数 : 自身 -> 成员 -> 父类**
* **构造函数不能是虚函数**，因为它们负责创建对象，而**虚拟调度依赖于完全构造的对象**，在基类构造函数完成之前，**虚拟表 (vtable) 尚未完全设置**。
* **构造函数的调用顺序为: 父类 -> 成员 -> 自身**; 

### 默认拷贝构造函数

拷贝构造函数是一种特殊的构造函数，用于创建一个新对象作为现有对象的副本。
拷贝构造函数在以下情况下会被调用：

* 当使用**拷贝初始化时**，即使用类的一个对象去初始化另一个同类型的对象时。
* 一个**函数**将对象作为实参传递给**非引用类型的形参**。pass by value的时候复制
* 当**函数的返回值是类的对象而非引用**，函数执行完返回调用者的时候。

具体的，拷贝构造函数会根据每个成员的类型决定其拷贝：

* 类类型成员，使用拷贝构造函数拷贝
* 内置类型成员，直接拷贝，特别的，对于**指针类型数据**而言，会出现**浅拷贝**问题

### 拷贝赋值运算符

拷贝赋值运算符是一个特殊的成员函数，用于通过 **=** 将一个现有对象的值赋给另一个对象。**通常返回**一个指向**左侧运算对象的引用**,与标准库进行统一,以便支持链式赋值。

### 取址运算符

返回对象的内存地址

```C++
Empty* operator&();
// 在类的非常量实例上调用它

const Empty* operator&() const;
// 在类的常量实例上调用它
// 第二个const （成员函数） ：表示该函数本身不会修改对象的状态，可以在const对象上调用。
// 第一个const （返回类型） ：表示函数返回的指针指向一个const对象，意味着该对象不能通过该指针修改。


```

### 移动构造函数和移动赋值运算符(since C++11)

**移动构造函数**是一个特殊的构造函数，它能够从一个**右值引用**（rvalue reference）创建新的对象，而**无需**进行**拷贝**,减少不必要的数据拷贝和资源分配, 而是**重新指定资源的所有权关系**,**提高**程序的**性能**和效率。

在移动构造函数和移动赋值操作符中，我们通过使用右值引用（&&）来标识移动语义，并**使用std::move()**函数将对象**转换为右值以调用移动语义**, 通常对**将亡值**使用。

## C++浅拷贝深拷贝

同一类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为浅拷贝.
 一般情况下，浅拷贝没有任何副作用，但是当类中有指针，并且指针指向动态分配的内存空间, 会导致内存问题。如改变量会同时改变二者，析构函数内存释放时会同时清楚二者。

## C++对象在内存存放的位置

* `new` 和 `malloc` 动态创建出来的对象在**堆区**
* 
    ```C++
    Object obj {};
    ```
    利用这种静态方式创建的对象，内存分配取决于上下文：
    * 全局/静态对象->全局静态区
    * 函数内部->栈区
    * 在一个类的内部，跟随这个类。
* **全局变量**，**静态全局变量**，**静态局部变量**，**静态成员变量**存放在**全局静态区**
* 所有**函数**都存放在**代码区**，函数告诉程序一段指令的**首地址**，**参数类型**和**返回值类型**
* **函数内局部变量**在**栈区**

## C++中的多级指针、泛型指针、与函数指针

对于一个**变量**，我们关注变量的**类型**和**值**，对于一个指针，我们需要的是**解类型**和**地址**。

### 多级指针

**多级指针**就是一个 **“解类型仍为指针”** 的一种指针.

```C++
    int value = 42;
    int* ptr = &value;      // 单级指针，指向变量 value, 解类型为int
    int** ptr2 = &ptr;      // 二级指针，指向指针 ptr, 解类型为int *
    int*** ptr3 = &ptr2;    // 三级指针，指向指针 ptr2, 解类型为int **

    std::cout << "Value: " << value << std::endl;               // 输出变量值
    std::cout << "Value via ptr: " << *ptr << std::endl;        // 通过单级指针访问值
    std::cout << "Value via ptr2: " << **ptr2 << std::endl;     // 通过二级指针访问值
    std::cout << "Value via ptr3: " << ***ptr3 << std::endl;    // 通过三级指针访问值
```

### 泛型指针

**泛型指针**是 **“解类型为空(void)”** 的指针。提供了一种通用的数据处理方式，但需要在使用时进行**显式的类型转换**, 将泛型指针转换为特定类型的指针,再进行具体的处理。

```C++
    int i = 42;
    float f = 3.14f;
    double d = 2.718;

    void* ptr;

    ptr = &i;
    std::cout << "Integer value: " << *static_cast<int*>(ptr) << std::endl;

    ptr = &f;
    std::cout << "Float value: " << *static_cast<float*>(ptr) << std::endl;

    ptr = &d;
    std::cout << "Double value: " << *static_cast<double*>(ptr) << std::endl;
```

### 函数指针

对于**函数**, 包含有三个要素: (1)**首地址**; (2)**参数**; (3)**返回值**。
**函数指针**保存的就是**函数的首地址**, 用来指向函数、调用函数等, 。
对一个**函数取地址**, 其实就是取这个**函数首地址的值**。

函数指针的定义一般是这种格式: 返回型+函数指针名+入参类型。
```C++
return_type (*pointer_name) (parameter_types);
```

```C++
// 定义 add 函数
void add(int a, int b) {
    std::cout << "Addition: " << (a + b) << std::endl;
}

// 定义 executeOperation 函数
void executeOperation(void (*operation)(int, int), int x, int y) {
    operation(x, y);  // 通过函数指针调用函数
}

int main() {
    // 定义函数指针
    void (*funcPtr)(int, int);

    // 将函数指针指向具体的函数
    funcPtr = &add; // or funcPtr = add, 函数类型会隐式转换为函数指针类型
    funcPtr(5, 3);  // 调用 add 函数
    // 也可写作 (*funcPtr)(5,3),  解函数指针后仍然是函数指针类型
    // 调用 executeOperation 并传递函数指针
    executeOperation(&add, 5, 3);
    return 0;
}
```

函数类型会隐式转换为函数指针类型；
解函数指针后仍然是函数指针类型;

## C++const和constexpr关键字

### const

const**修饰变量**使其**只读(Read-only)**

```C++
// const修饰指针的三种情况
int a = 10;
int b = 10;

//常量指针
const int * p1 = &a; 
//解类型为const int 的指针，指针指向可以改，解指针的值不可以更改
p1 = &b; //正确
//*p1 = 100;  报错

//指针常量
int * const p2 = &a;
//int指针是const的，指针的值，即指向不可以改。但解指针的值可以更改
//p2 = &b; //错误
*p2 = 100; //正确

//指向常量的常指针
//const既修饰指针又修饰常量
const int * const p3 = &a;
//p3 = &b; //错误
//*p3 = 100; //错误
```

const**修饰引用**

作用为不可通过该引用来改变引用的值。**常用于函数传参**和**for loop遍历**。

对于**const变量的引用要用const引用**, 非const的变量也可

```C++
const int ci = 10;
const int& r1 = ci; // ok  r1是常量引用，对应的对象ci也是常量

int i = 50;
const int& r2 = i;     // ok  将int常量引用绑定到int变量上
```

const支持**隐式类型转换**和**绑定右值**, 都是**为了函数传参**

```C++
// 绑定右值
const int& r3 = 10;    // ok  将int常量引用绑定到int右值上
int& r4 = 10;          // err 非常量引用不能绑定右值

// 隐式类型转换
double pi = 3.14;
const int& rpi = pi;   // ok  将int常量引用绑定到double变量上
int& rpi = pi;         // err 非常量引用的类型要和所绑定的对象的类型严格匹配
```

当一个**函数的返回值是一个值而非引用**，那么返回的是一个**临时变量**，且具有**常量性**。**如果要用引用接收该值，只能用常量引用。**

```C++
int Count() {
    int n = 0;
    n++;
    return n;
}
 
int& ret = Count();       // err
const int& ret = Count(); // ok
```

### constexpr

**C++11**新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。
**constexpr关键字指明变量其后是一个常量**,编译器在**编译**程序**时**可以顺带将其结果**计算**出来,而**无需等到程序运行阶段**,这样的优化极大地提高了程序的执行效率
声明为constexpr的变量**一定是一个常量**，而且**必须用常量表达式初始化**

```C++
constexpr int mf = 20;  //20是常量表达式
constexpr int limit = mf + 1; // mf + 1是常量表达式
constexpr int sz = size(); //当size是一个constexpr函数时才是一条正确的声明语句
```

**constexpr函数**
**在编译期间就能得到值**，需要保证其函数体中只包含不依赖于运行时状态的代码，具体来说，只能使用常量值、枚举、非递归的结构体、指向函数或对象的指针等，不允许使用运行时变量、分支语句和循环语句等, **constexpr函数被隐式地定义为内联函数**

```C++
constexpr int foo(int i)
{
    return i + 5;
}
```


## C语言编译的四个阶段

‌C语言编译的四个过程包括‌**预处理、‌编译、‌汇编和‌链接‌**。这些过程将源代码转换为可执行文件，每个过程都有其特定的任务和目标。

每个过程的具体内容和作用：

**‌预处理‌：** 在源代码文件被编译之前进行一些处理，**包括宏定义展开、头文件包含、条件编译等操作**。预处理器会读取源代码文件中以#开头的命令，并执行相应的操作，例如#include命令会将指定的头文件内容包含到源代码文件中。

**‌编译‌：** **将源代码文件转换为汇编代码**的过程。编译器会对源代码进行语法分析、语义分析、优化等操作，并生成相应的汇编代码。如果源代码中存在语法错误或类型不匹配等问题，编译器会生成相应的错误信息。

**‌汇编‌：** **将汇编代码转换为机器码**的过程。汇编器会读取汇编代码，并将其转换为机器指令、数据区等内容。在汇编过程中，会生成符号表、重定位表等信息，以便后续的链接操作使用。

**‌链接‌：** **将多个目标文件合并为一个可执行文件**的过程。链接器会对目标文件进行符号解析、符号重定位等操作，并生成可执行文件。在链接过程中，会将目标文件中的未定义符号与其他目标文件中的定义符号进行关联，以便生成最终的可执行文件。