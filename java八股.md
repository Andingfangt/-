#### 1. ArrayList 和 LinkedList 区别:

* `ArrayList` 是通过数组实现的，当数组空间不足时需要进行扩容操作，插入和删除元素时需进行元素的移动，效率较低；支持随机访问，时间复杂度为 $O(1)$。
* `LinkedList` 是基于双向链表实现的, 插入和删除元素时只需要改变相邻节点的指针, 不支持随机访问，需要从头或尾节点开始遍历，时间复杂度为 $O(n)$。

#### 2. HashMap 原理，底层

* `HashMap`是一种基于哈希表的数据结构，用于存储**键值对**, 底层实现是**数组（bucket）+链表/红黑树**, 非synchronized线程不安全;
* 当创建一个 HashMap 实例时，它会初始化一个默认大小的数组（默认为16），每个数组元素是一个链表;
* 在 Java 8 中，如果链表的长度超过了 8 ，那么链表将转化为红黑树；链表长度低于6，就把红黑树转回链表;
* put() 和 get() 方法通过计算键 key 的 hashCode() 值，然后根据该值计算该键值对应在数组中的位置（求余）;
* **扩容** 当 HashMap 中存储的键值对数量超过数组大小的一定值时（默认75%），就会触发扩容操作。具体来说，HashMap 会将数组大小翻倍，并重新计算每个键值对在新数组中的位置并重新放置。
* 作为key对象,必须实现hashCode和equals,并且key的内容不能修改；当两个元素的hashCode的值相等,通过equals判断是否为相同的元素
* 允许key/value为空

#### 3. 其余 Java::Map 接口

![图 0](images/f87714c78a6e1d0d556878e3496bf820d3af8fad3b0483fe5118349eff098430.png)  

##### LinkedHashMap: HashMap子类:

* 相较于 HashMap 后者多维护着一个存储所有条目的双向链表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。
* 重要成员变量与重要内部方法：
  * 1. `accessOrder`：
        默认为 false（即默认按照插入顺序迭代, 使用 put() 方法时，新加入元素加入双向链表末尾
        为 true 时（按照访问顺序迭代，支持实现 LRU 算法时, 使用 get() 方法时会把 get 到的元素放入双向链表尾部
  * 2. `removeEldestEntry(Map.Entry)`:
        默认返回 false
        可以重写该方法来制定添加元素时的策略。方法内部返回 true 时，当要往该map中存放（put\putAll）元素时，就先删除最老的对象，然后再添加新对象。

##### Hashtable类:

* 无序，底层数组+链表，线程安全（采用synchronized修饰）, 所有方法都加同步锁，在多线程运行环境下效率表现非常低下。当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态，**废弃，不推荐使用**，现版本在多线程的情况下使用线程安全类时多被ConcurrentHashMap取代

##### SortedMap的实现类：TreeMap:

* 有序，底层红黑树，线程不安全，构造函数中提供了参数`Comparator`，可以自定义实现排序

##### ConcurrentMap的实现类：ConcurrentHashMap:

* 线程安全, 加锁的高效性
* JDK1.7版本的CurrentHashMap的实现原理: 数组+Segment(分段锁), 将数据分成一段一段的存储(默认16片)，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。
* JDK1.8版本的CurrentHashMap的实现原理: 数组+链表/红黑树，内部大量采用**CAS**(compare and swap)操作。


#### 4. 悲观锁和乐观锁

##### 悲观锁（Pessimistic Locking）：

* 对资源持有较悲观态度的锁定方式。它假设数据在并发访问时极有可能发生冲突，因此每次访问数据前都会先加锁，共享资源每次只给一个线程使用。
* Java中，`synchronized`从偏向锁、轻量级锁到重量级锁，**全是悲观锁**。JDK提供的Lock实现类**全是悲观锁**。
* 常见的实现方式是传统的关系型数据库中的行级锁、表级锁、读锁、写锁等等。
* 适用于高并发、数据竞争激烈的场景，如金融交易、库存管理等。这类场景下，冲突发生的可能性很高，所以加锁确保数据的一致性。 
* 缺点：
  * 1.**性能不高**，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗
  * 2.**系统吞吐量降低**，因为锁定机制会阻止其他线程并发访问资源。
  * 3.**容易产生死锁（Deadlock）**，如果锁的持有和释放管理不当，会导致系统无法继续运行。


##### 乐观锁（Optimistic Locking）:

* 对资源持相对乐观的态度，假设并发操作冲突的可能性较小，因此不会主动加BB而是进行数据版本检查来决定是否提交操作。
* 常见的实现方式有**版本号机制**和**CAS算法**实现。
* CAS请求参数：V(内存地址)，A(旧的预期值)，B(要修改的更新值)。当且仅当旧的预期值A和内存地址V处的值相同时，将内存值V修改为B，否则什么都不做或重来。
* 适用于多读的应用，如阅读类应用、CMS系统等。
* 发生冲突时线程回滚重试
* 缺点：
  1. 在并发冲突频繁的场景下，可能会导致大量重试操作，影响性能.
  2. 需要显式管理版本控制机制.


#### 5. Java虚拟机(JVM)垃圾回收(GC)机制和常见垃圾收集器

##### GC Roots：

* 必定存活的对象
* 对象的引用是一组树状结构（不是网状，有环就内存泄漏了），沿着GC Roots节点全盘梳理，那么没有被引用到的对象，就已经可以被回收掉了，这种方法被称为可达性分析

##### STW（stop the world）：

* 为了垃圾回收，需要暂停我们的业务代码
* 如果尽可能降低STW的时间----“并发”。因此，各种垃圾回收算法开始从垃圾回收流程上进行优化拆解，引入各种可以的“并发”过程，控制STW的时间。

##### 垃圾回收算法：

* `标记-复制算法`：将内存分隔为两块相同大小的区域，每次只使用其中的一块，每当GC完成后，将存活的对象复制到另一块区域，然后将前一块清空。
* `标记-清除算法`：分为标记和清除两个阶段，标记存活的对象，然后GC清除掉没有被标记的对象。
* `标记-整理算法`：大体流程和标记清除法一致，但是它具有整理内存空间的功能。这种算法避免了内存碎片化的问题，但是效率上相对于标记-清除法略低。


##### 分代收集理论:

* JVM的大部分虚拟机将堆空间逻辑划分为新生代/年轻代、老年代，垃圾收集器可以根据不同的区域选择不同的回收算法进行GC。
![图 1](images/b5c7fd5d8195f689d611f50ec1d1a1f3b2f9992d94dfe458a2941c03c30d83a8.png) 

##### CMS收集器（Concurrent Mark Sweep）：

* 老年代收集器，基于标记清除算法，JDK8默认, 适用于要求低延迟的应用场景
* `阶段一：初始标记`: 将GC Roots作为根节点扫码与之直连的对象，速度较快耗时很短，但是会暂停用户线程STW。
* `阶段二：并发标记`: 从上一阶段GC Roots直连的对象作为开始，通过可达性分析算法扫码整个堆，标记出所有可达的对象，这个过程很长，但是可以和用户线程并发执行，所以没有STW。但是并发标记阶段会存在多标、漏标的问题。
* `阶段三：重新标记`：修正并发标记阶段因为用户线程在执行可能导致对象的引用链发生变化而产生的错误标记，该过程需STW。
* `阶段四：并发清理`：清除所有不可达的对象。
* `阶段五：并发重置`：阶段重置本次GC过程中标记的数据。

##### G1垃圾收集器（Garbage First）：

* 分代标记, 宏观上表现为标记-整理算法，但微观Region是复制算法；将堆空间分为多个区域（Eden, Surviver, Old），分别进行垃圾收集，并根据区域中的对象分布情况来进行垃圾收集， JDK11 默认。
* G1的回收分类: 在一般情况下，只需要针对新生代做`YoungGC`, 当内存使用率过高时，再触发`MixedGC`对所有分区进行整体回收。
* 适用于大内存、多核CPU的场景。
* `阶段一：初始标记`：同CMS, 从GC roots开始做可达性分析（在young GC时，由于不回收老年代，还需加上老年代的对象）， STW短暂
* `阶段二：并发标记`: 同CMS；
* `阶段三：最终标记`：同CMS处理多标和漏标，但是漏标的问题和CMS处理手段不一样，CMS使用的是增量更新，G1使用的是原始快照。
* `阶段四：筛选回收`：对各个Region区域做回收的成本分析，根据用户设置的期望GC停顿时间来制定回收计划。回收阶段针对Region使用复制算法，将标记了的对象复制到临近的空闲区域，从宏观上来说类似于G1采用了标记-整理法，这种模式相对于CMS而言减少了内存碎片的问题。


#### 6. 产生死锁的必要条件

* `互斥条件`: 进程对资源的访问是排他的
* `占有且等待资源`: 一个进程申请资源得不到满足时处于等待资源的状态，且不释放已占资源
* `不可抢占`：资源不能被抢占，只能由进程持有者显式释放
* `循环等待`: 等待队列成环

#### 7. JVM的组成

##### JVM是什么

Java虚拟机用于运行Java程序编译出来的字节码，屏蔽了与具体操作系统平台相关的信息，从而实现跨平台的运行.

![图 2](images/17c365d6c64f1072879fa5963b554a6ddc9b48f2e9359992712d7c873cdfd90f.png)  

##### JVM主要组成部分

* `运行时数据区`(JVM内存， 本地内存)
* `执行引擎`(JC，GC)
* `本地接口`
* `本地方法库`

##### JVM内存结构

JVM内存结构指的是JVM运行时数据区结构，它主要包含以下几个部分：

* `堆（Heap）`：**线程共享**，最大内存区域
  * `存储对象实例和数组`: 保存所有 **new** 关键字创建的对象， 分为新生代（伊甸区，幸存区（S1,S2））和老年区，比例为1：1：8， 创建的对象首先进入Eden区，当Eden内存不足时，触发**MinorGC**（又称**YoungGC**）, 将存活对象复制到Survivor区，依次类推，当老年去也内存不足时，触发 **FullGC** 回收整个堆的非存活对象，如果采用G1垃圾回收器则触发**MixedGC**.
  * `字符串常量池`: 用于存储字符串常量。在Java中，字符串常量是不可变的，因此可以被共享。这样可以减少内存的使用，提高程序的性能。
  * `静态变量`: 指在类中定义的变量，它们的值在整个程序运行期间都不会改变。
  * `线程本地分配缓冲区（TLAB）`: 用于提高线程分配对象时的效率。
* `方法区（Method Area）`：**线程共享**
  * `常量池`: 存储静态变量（由字母、数字等构成的字符串或者数字常量）和符号引用
  * `类信息`: 加载到方法区中的Class文件信息
  * `即时编译的代码缓存`
* `虚拟机栈（VM Stack）`：线程私有。
* `程序计数器（Program Counter Register）`：线程私有。
* `本地方法栈`（Native Method Stack）：线程私有。