## 1. ArrayList 和 LinkedList 区别:

* `ArrayList` 是通过数组实现的，当数组空间不足时需要进行扩容操作，插入和删除元素时需进行元素的移动，效率较低；支持随机访问，时间复杂度为 $O(1)$。
* `LinkedList` 是基于双向链表实现的, 插入和删除元素时只需要改变相邻节点的指针, 不支持随机访问，需要从头或尾节点开始遍历，时间复杂度为 $O(n)$。

## 2. HashMap 原理，底层

* `HashMap`是一种基于哈希表的数据结构，用于存储**键值对**, 底层实现是**数组（bucket）+链表/红黑树**, 非synchronized线程不安全;
* 当创建一个 HashMap 实例时，它会初始化一个默认大小的数组（默认为16），每个数组元素是一个链表;
* 在 Java 8 中，如果链表的长度超过了 8 ，那么链表将转化为红黑树；链表长度低于6，就把红黑树转回链表;
* put() 和 get() 方法通过计算键 key 的 hashCode() 值，然后根据该值计算该键值对应在数组中的位置（求余）;
* **扩容** 当 HashMap 中存储的键值对数量超过数组大小的一定值时（默认75%），就会触发扩容操作。具体来说，HashMap 会将数组大小翻倍，并重新计算每个键值对在新数组中的位置并重新放置。
* 作为key对象,必须实现hashCode和equals,并且key的内容不能修改；当两个元素的hashCode的值相等,通过equals判断是否为相同的元素
* 允许key/value为空

## 3. 其余 Java::Map 接口

![图 0](images/f87714c78a6e1d0d556878e3496bf820d3af8fad3b0483fe5118349eff098430.png)  

### LinkedHashMap: HashMap子类:

* 相较于 HashMap 后者多维护着一个存储所有条目的双向链表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。
* 重要成员变量与重要内部方法：
  * 1. `accessOrder`：
        默认为 false（即默认按照插入顺序迭代, 使用 put() 方法时，新加入元素加入双向链表末尾
        为 true 时（按照访问顺序迭代，支持实现 LRU 算法时, 使用 get() 方法时会把 get 到的元素放入双向链表尾部
  * 2. `removeEldestEntry(Map.Entry)`:
        默认返回 false
        可以重写该方法来制定添加元素时的策略。方法内部返回 true 时，当要往该map中存放（put\putAll）元素时，就先删除最老的对象，然后再添加新对象。

### Hashtable类:

* 无序，底层数组+链表，线程安全（采用synchronized修饰）, 所有方法都加同步锁，在多线程运行环境下效率表现非常低下。当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态，**废弃，不推荐使用**，现版本在多线程的情况下使用线程安全类时多被ConcurrentHashMap取代

### SortedMap的实现类：TreeMap:

* 有序，底层红黑树，线程不安全，构造函数中提供了参数`Comparator`，可以自定义实现排序

### ConcurrentMap的实现类：ConcurrentHashMap:

* 线程安全, 加锁的高效性
* JDK1.7版本的CurrentHashMap的实现原理: 数组+Segment(分段锁), 将数据分成一段一段的存储(默认16片)，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。
* JDK1.8版本的CurrentHashMap的实现原理: 数组+链表/红黑树，内部大量采用**CAS**(compare and swap)操作。


## 4. 悲观锁和乐观锁

### 悲观锁（Pessimistic Locking）：

* 对资源持有较悲观态度的锁定方式。它假设数据在并发访问时极有可能发生冲突，因此每次访问数据前都会先加锁，共享资源每次只给一个线程使用。
* Java中，`synchronized`从偏向锁、轻量级锁到重量级锁，**全是悲观锁**。JDK提供的Lock实现类**全是悲观锁**。
* 常见的实现方式是传统的关系型数据库中的行级锁、表级锁、读锁、写锁等等。
* 适用于高并发、数据竞争激烈的场景，如金融交易、库存管理等。这类场景下，冲突发生的可能性很高，所以加锁确保数据的一致性。 
* 缺点：
  * 1.**性能不高**，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗
  * 2.**系统吞吐量降低**，因为锁定机制会阻止其他线程并发访问资源。
  * 3.**容易产生死锁（Deadlock）**，如果锁的持有和释放管理不当，会导致系统无法继续运行。


### 乐观锁（Optimistic Locking）:

* 对资源持相对乐观的态度，假设并发操作冲突的可能性较小，因此不会主动加BB而是进行数据版本检查来决定是否提交操作。
* 常见的实现方式有**版本号机制**和**CAS算法**实现。
* CAS请求参数：V(内存地址)，A(旧的预期值)，B(要修改的更新值)。当且仅当旧的预期值A和内存地址V处的值相同时，将内存值V修改为B，否则什么都不做或重来。
* 适用于多读的应用，如阅读类应用、CMS系统等。
* 发生冲突时线程回滚重试
* 缺点：
  1. 在并发冲突频繁的场景下，可能会导致大量重试操作，影响性能.
  2. 需要显式管理版本控制机制.



## 5. Java虚拟机(JVM)垃圾回收(GC)机制和常见垃圾收集器

### GC Roots：

* 必定存活的对象
* 对象的引用是一组树状结构（不是网状，有环就内存泄漏了），沿着GC Roots节点全盘梳理，那么没有被引用到的对象，就已经可以被回收掉了，这种方法被称为可达性分析

### STW（stop the world）：

* 为了垃圾回收，需要暂停我们的业务代码
* 如果尽可能降低STW的时间----“并发”。因此，各种垃圾回收算法开始从垃圾回收流程上进行优化拆解，引入各种可以的“并发”过程，控制STW的时间。

### 垃圾回收算法：

* `标记-复制算法`：将内存分隔为两块相同大小的区域，每次只使用其中的一块，每当GC完成后，将存活的对象复制到另一块区域，然后将前一块清空。
* `标记-清除算法`：分为标记和清除两个阶段，标记存活的对象，然后GC清除掉没有被标记的对象。
* `标记-整理算法`：大体流程和标记清除法一致，但是它具有整理内存空间的功能。这种算法避免了内存碎片化的问题，但是效率上相对于标记-清除法略低。


### 分代收集理论:

* JVM的大部分虚拟机将堆空间逻辑划分为新生代/年轻代、老年代，垃圾收集器可以根据不同的区域选择不同的回收算法进行GC。
![图 1](images/b5c7fd5d8195f689d611f50ec1d1a1f3b2f9992d94dfe458a2941c03c30d83a8.png) 

### 三色标记算法

三色标记算法是一种常用的根可达性分析算法，它主要用于标记可达对象和不可达对象。在三色标记算法中，垃圾回收器将对象分为三种颜色：黑色、灰色和白色。

![图 4](images/342830b0b9dee867b0fdc728e5efe97c57a604ac9c523b798cbeacf3db3b83be.png)  

算法的大致流程（初始状态所有对象都是白色）：

* 从根对象开始，将所有可达的对象标记灰色，根对象标记为黑色
* 遍历所有灰色对象，将它们引用的对象标记为灰色，自己标记为黑色
* 最后垃圾回收所有白色标记对象。

并发标记（不STW）带来的漏标和错标：

* 本应该是垃圾的对象被视为了非垃圾（浮动垃圾）：已经被标记为黑色或灰色的对象被断开而变为不可达的垃圾，影响不大，下次GC会收集
* 本应该不是垃圾的对象被视为了垃圾: 尚未被算法分析到的白色对象成为黑色对象的引用，由于黑色对象已经分析过了，该白色对象将无法再被标记为灰色。**影响很大**。

解决方法：

* `读写屏障`：在读写操作前后插入一段代码，用于记录一些信息、保存某些数据等
* `增量更新`（Incremental Update）, CMS用于解决漏标的处理方式:
  * 当黑色对象新增一个白色对象的引用时，就通过写屏障将这个引用关系记录下来。
  * 在重新标记阶段，将这些引用关系中的黑色对象变为灰色，再扫描一次，以此保证不会错误被GC当成垃圾对象被回收
  * 重新标记需要STW，防止在重新标记阶段如果用户线程还是继续执行造成无限循环
* `原始快照`（SATB，Snapshot At The Beginning）, G1垃圾收集器解决漏标的办法:
  * 在灰色对象断开对白色对象的引用时，通过写屏障中记录被置空的白色对象
  * 在重新标记阶段，将这些引白色对象变为灰色，再扫描一次
  * 优点：效率会更高，重新标记阶段的层次更低（增量更新变换的灰色对象是原始快照的父级）
  * 缺点：若记录的对象实际无被任何引用但标记为灰色，则会带来更多浮动垃圾
  * G1选择原始快照的原因：G1收集多代的垃圾，对象跨代引用扫描代价更大，若采用增量更新STW时间会较长。

### CMS收集器（Concurrent Mark Sweep）：

* 老年代收集器，基于标记清除算法，JDK8默认, 适用于要求低延迟的应用场景
* `阶段一：初始标记`: 将GC Roots作为根节点扫码与之直连的对象，速度较快耗时很短，但是会暂停用户线程STW。
* `阶段二：并发标记`: 从上一阶段GC Roots直连的对象作为开始，通过可达性分析算法扫码整个堆，标记出所有可达的对象，这个过程很长，但是可以和用户线程并发执行，所以没有STW。但是并发标记阶段会存在多标、漏标的问题。
* `阶段三：重新标记`：修正并发标记阶段因为用户线程在执行可能导致对象的引用链发生变化而产生的错误标记，该过程需STW。
* `阶段四：并发清理`：清除所有不可达的对象。
* `阶段五：并发重置`：阶段重置本次GC过程中标记的数据。

### G1垃圾收集器（Garbage First）：

* 分代标记, 宏观上表现为标记-整理算法，但微观Region是复制算法；将堆空间分为多个区域（Eden, Surviver, Old），分别进行垃圾收集，并根据区域中的对象分布情况来进行垃圾收集， JDK11 默认。
* G1的回收分类: 在一般情况下，只需要针对新生代做`YoungGC`, 当内存使用率过高时，再触发`MixedGC`对所有分区进行整体回收。
* 适用于大内存、多核CPU的场景。
* `阶段一：初始标记`：同CMS, 从GC roots开始做可达性分析（在young GC时，由于不回收老年代，还需加上老年代的对象）， STW短暂
* `阶段二：并发标记`: 同CMS；
* `阶段三：最终标记`：同CMS处理多标和漏标，但是漏标的问题和CMS处理手段不一样，**CMS使用的是增量更新**，**G1使用的是原始快照**。
* `阶段四：筛选回收`：对各个Region区域做回收的成本分析，根据用户设置的期望GC停顿时间来制定回收计划。回收阶段针对Region使用复制算法，将标记了的对象复制到临近的空闲区域，从宏观上来说类似于G1采用了标记-整理法，这种模式相对于CMS而言减少了内存碎片的问题。

### ZGC垃圾收集器（Z Garbage Collector）：

一款基于Region内存布局的，不设分代（不分老年代、新生代）的，使用了读屏障、染色指针和内存多重映射等技术来实现的基于标记-整理算法实现的，以低延迟为首要目标的一款并发的垃圾收集器。

### *Pythoy的内存管理

引用计数： Python 主要采用引用计数的方式来管理内存。每个对象都有一个引用计数器，当引用计数为 0 时，对象就会被销毁。标记-清除： 为了解决循环引用问题，Python 引入了标记-清除算法，周期性地扫描所有对象，标记可达对象，然后回收不可达对象。分代回收： Python 将对象分为不同的代，新创建的对象属于年轻代，存活时间长的对象属于年老代。不同代的回收频率不同，以优化回收效率。

### *Go 采用三色标记法进行垃圾标记清除回收。

###. 产生死锁的必要条件

* `互斥条件`: 进程对资源的访问是排他的
* `占有且等待资源`: 一个进程申请资源得不到满足时处于等待资源的状态，且不释放已占资源
* `不可抢占`：资源不能被抢占，只能由进程持有者显式释放
* `循环等待`: 等待队列成环

## 7. JVM的组成

### JVM是什么

Java虚拟机用于运行Java程序编译出来的字节码，屏蔽了与具体操作系统平台相关的信息，从而实现跨平台的运行.

![图 2](images/17c365d6c64f1072879fa5963b554a6ddc9b48f2e9359992712d7c873cdfd90f.png)  

### JVM主要组成部分

* `运行时数据区`(JVM内存， 本地内存)
* `执行引擎`(JC，GC)
* `本地接口`
* `本地方法库`

### JVM内存结构

JVM内存结构指的是JVM运行时数据区结构，它主要包含以下几个部分：

* `堆（Heap）`：**线程共享**，最大内存区域
  * `存储对象实例和数组`: 保存所有 **new** 关键字创建的对象， 分为新生代（伊甸区，幸存区（S1,S2））和老年区，比例为1：1：8， 创建的对象首先进入Eden区，当Eden内存不足时，触发**MinorGC**（又称**YoungGC**）, 将存活对象复制到Survivor区，依次类推，当老年去也内存不足时，触发 **FullGC** 回收整个堆的非存活对象，如果采用G1垃圾回收器则触发**MixedGC**.
  * `字符串常量池`: 用于存储字符串常量。在Java中，字符串常量是不可变的，因此可以被共享。这样可以减少内存的使用，提高程序的性能。
  * `静态变量`: 指在类中定义的变量，它们的值在整个程序运行期间都不会改变。
  * `线程本地分配缓冲区（TLAB）`: 用于提高线程分配对象时的效率。
* `方法区（Method Area）`：**线程共享**
  * `类信息`: 加载到方法区中的Class文件信息
  * `运行时常量池`: 存储程序运行时的静态变量（由字母、数字等构成的字符串或者数字常量）和符号引用
  * `即时编译的代码缓存`
* `虚拟机栈（VM Stack）`：**线程私有**
  * 每个线程运行时创建自己的虚拟机栈，每个栈由多个栈帧（Stack Frame）组成，每个方法被执行时，Java虚拟机都会同步创建一个栈帧用于存储该方法的局部变量表、操作数栈、动态链接、方法返回地址等信息
* `本地方法栈`（Native Method Stack）：线程私有
  * 类似虚拟机栈, 但服务于本地方法的调用。
* `程序计数器（Program Counter Register）`：**线程私有**
  * 可看作是当前线程所执行的字节码的行号指示器。

## 8. JVM、JRE和JDK的关系是什么

![图 3](images/070c46bdc0598d2ead1045fb783b4df272345e2d8694ca3932923c65f4e629bb.png)  

* `JVM`: **Java Virtual Machine** Java虚拟机
  * JVM 是一个运行在操作系统之上的虚拟机，用于执行javac（Java编译器）将Java代码(.java)转换而来的字节码(.class)
  * JVM 读取字节码并生成机器特定代码。为了生成特定于机器的代码(最后交给本机CPU执行)，JVM 需要是特定于机器的。因此每种类型的机器（Windows / Linux / Mac）都有一个特定的 JVM。
  * JVM 提供了Java的可移植性
* `JRE`: **Java Runtime Environment** Java运行环境 = JVM + 运行应用程序所需的库。
  * 如果您只需要运行已编译的 Java 程序，但不需要开发它们，那么 JRE 就是您所需要的
* `JDK`: **Java Development Kit** Java开发工具包 = JRE + 开发Java应用程序所需的工具和库。
  * 工具包括编译器（javac）、调试器(Java Debugge)、文档生成器(JavaDoc)等


## 9. Java string 特性

* 不能被继承： String类是final修饰的，不能被继承（final修饰的类不能被继承，修饰的方法不能被重写，修饰的变量为常量。）
* 设计成不可变的原因：
  * `字符串常量池的设计`：JVM堆中字符串常量池的存在，多个字符串对象可以共享同一个字符串常量，减少内存占用。
  * `安全性`: 防止被攻击修改
  * `提高缓存利用率和性能`： 能被多个线程安全共享，不需要额外的同步措施
* 实际使用中如果需要进行字符串拼接等操作，可以使用`StringBuilder`或`StringBuffer`类, 其中StringBuffer是线程安全的。


## 10. Array和ArrayList 区别

* `Array` 是一种静态数据结构，长度固定, 在声明时需要指定长度，可以存储基本类型和对象类型，不支持泛型
* `ArrayList` 动态数组，长度可以动态扩容，只能包含对象类型，支持泛型，有许多实用API, 线程不安全，如需安全可使用List接口下的另一个`vector`, 它在每个方法上都使用了synchronized关键字进行同步锁。

## 11. Java中volatile关键字

* 保证了不同线程之间对共享变量操作的**可见性**。volatile修饰的共享变量在执行写操作后，会立即刷回到主存，以供其它线程读取到最新的记录。
* 通过禁止编译器、CPU指令重排序和部分hapens-before规则，解决**有序性**。
* 对单个volatile修饰变量的读/写具有原子性，类似于i++这种复合操作不具有原子性。
* volatile仅保证最低限度的原子操作, 生产中还是推荐synchronized 、或者Lock锁。

## Java的面向对象的四大特性

与C++特性相似

### 一. 封装

我们将类的属性（私有化），同时，提供公共的（public）方法来获取（getxxx）和设置（setxxx）此属性的值

Java规定的四种权限：（从小到大排列）：**private、缺省、protected、public**

| 修饰符     | 类内部 | 同一个package | 不同包的继承子类 | 同一个工程 |
|------------|--------|----------|--------------|------------|
| private    | $\checkmark$    |          |              |            |
| 缺省       | $\checkmark$    | $\checkmark$      |              |            |
| protected  | $\checkmark$    | $\checkmark$      | $\checkmark$          |            |
| public     | $\checkmark$    | $\checkmark$      | $\checkmark$          | $\checkmark$        |

### 二. 继承

继承性的格式：

```java
class A extends B {
  "some code"
}
```

* 一旦子类A继承父类B之后，子类A中获取父类B中生命的**所有**的结构、属性、方法。可显性使用**super**调用，或运行时获取最近的方法。

* 子类继承父类之后，还可以声明**自己特有**的属性和方法，实现功能的扩展

* 如果我们没有显示的声明一个类的父类的话，则此类继承于**Java.lang.Object类**

**重写override:**

子类继承父类之后，可以对父类中**同名同参数**的方法，进行**覆盖**操作, 记得加 **@override**修饰便于查错。

### 三. 多态

允许基类（父类）的引用指向派生类的对象，并调用相应的方法

多态性的使用前提：①要有类的**继承**关系。②要有方法的**重写**。

**编译时**类型由声明该变量时使用的类型决定(**左侧，即父类的引用**)，**运行时**类型由实际赋给该变量的对象决定（**右侧，即子类的对象**）。

### 四. 抽象

抽象性是指当设计一个类时，不让该类面向具体的类，而是面向抽象类或接口，具体的类实现时要实现抽象类中的全部定义方法。

**抽象类：**

在Java中，当用`abstract`关键字来修饰一个类时，这个类被称为抽象类, 抽象类可以有常量也可以有变量，可以有抽象方法也可有非抽象方法。

```java
public abstract class Geometry {
	String name;//图形名称
	//计算面积(抽象方法)
	public abstract double getArea();
}
```

非抽象子类用`extends`继承该抽象类并实现

```java
public class Rectangle extends Geometry{
  "..."
}
```

**接口：**

接口是一种特殊的抽象类，类似于C/C++的$.h$文件，但更严格，接口中**只能包含常量和抽象方法的定义**，而没有变量和具体方法的实现。在Java中，接口是通过`interface`关键字来定义

```java
public interface Geometry {}
```

为了使用接口，需要编写接口的实现类。Java使用`implements`关键字表示类实现接口，一个类可以同时实现多个接口，接口之间用逗号“,”分隔。

```java
public class Circle implements Geometry {}
```
