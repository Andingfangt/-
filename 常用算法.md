## 快速幂

```python
# 求 (a**b) % mod
def f(a, b, mod):
    ans = 1
    while(b):
        if b&1:
            ans *= a
            ans %= mod
        b >>= 1
        a *= a
        a %= mod
    return ans
```

## 组合数

```python
# 预处理 fac 和 ifac
fac = [1] * (n+1), ifac = [1] * (n+1)
for i in range(2,n+1):
    fac[i] = fac[i-1] * i % mod
    ifac[i] = pow(fac[i], mod - 2) # 使用快速幂

'''求C_a^b % mod'''
def C(a,b,mod):
    return fac[a] * ifac[b] % mod * ifac[a-b] % mod
```

## 埃拉托斯特尼筛法求素数

```python
# 预处理 is_prime
is_prime = [True] * (n+1)
p = 2 # 从 2 开始
while p*p <= n:
    if is_prime[p]: # 找到最近未被标记为非质数的质数
        for i in range(p*p, n+1, p): # 标记所有是它的倍数且>=p*p的数字
            is_prime[i] = False
    p += 1

'''判读 k 是否是质数'''
def isPrime(k):
    return is_prime[k]
```

## 二分图匹配-匈牙利算法

**二分图**：

* 可以将图中所有的点分为A、B两个集合，从而使得集合内部任意两个点都不直接相连。
* 常见为男，女配对，偶数，奇数配对。
![图 0](images/7ed7f07f7faecf3f7bf5c4dc673612dfae374c868f53502837676d4b7c4b1973.png)  

**一个二分图中的最大匹配数等于这个图中的最小点覆盖数**

**最大匹配**

* 即需要给出一种分配策略，使得产生尽可能多的符合条件的配对

**最小点覆盖**

* 找到最少的一些点，使二分图所有的边都至少有一个端点在这些点之中。倒过来说就是，删除包含这些点的边，可以删掉所有边。

```python
    graph = make_graph() # 根据题意构建图
    visited = set() # //记录右侧元素是否已被访问过
    mapRight = dict() #  //记录当前右侧元素所对应的左侧元素
    '''递归匹配'''
    def dfs(n_left: int)->bool:
        for n_right in graph[n_left]:
            # 访问过则跳过
            if n_right in visited:
                continue
            visited.add(n_right)
            # 如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配
            if n_right not in mapRight or dfs(mapRight[n_right]):
                mapRight[n_right] = n_left # 当前left侧元素成为当前right侧元素的新匹配
                return True # 返回匹配成功
        return False # 循环结束，仍未找到匹配，返回匹配失败
    '''匈牙利算法'''
    def Hungarian()->int:
        ans = 0
        for n_left in leftLst:
            visited.clear() # 重置vis数组
            if dfs(n_left):
                ans += 1
        return ans
```
