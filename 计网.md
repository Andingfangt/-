
#### 1.计网的七层/四层网络模型

![图 0](images/dcdc1479764d2bbef993db96e63040baf2697b71c8c45222113d95b39f68f4c4.png)  

#### 2.域名系统DNS

* DNS作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
* DNS的作用就是将网址解析为 IP 地址。（比如百度 www.baidu.com，其IP为$183.232.231.17$）
* DNS（‌域名系统）‌在大多数情况下使用UDP进行通信, 使得DNS查询和响应能够更快地进行, 但在DNS的某些特定任务中，‌如区域传输（‌zone transfer）‌，‌TCP也是被使用的。

#### 3. TCP的三次握手与四次挥手过程(结合CS144)

**三次握手(建立连接)**：
![图 1](images/a207e458b751fe1e619f128d0ff12c682d2153f9d4743e0481120c9980d27b1b.png)  

1. 客户端的Sender选取一个随机数作为ISN（即上图的seq=x），只将ISN包进TCP帧，payload=0，发给服务器的Receiver。
2. 服务器的Receiver返回一个包含着ackno=J+1以及窗口大小yy确认帧，这时客户端的Sender和服务器的Receiver达成同步，都将x+1作为整个数据流的初始位置（建立第一条链接）
3. 同样的，服务器的Sender和客户端的Receiver也进行同样的操作，只不过此时服务器的Sender随机选择的是y
4. 客户端的Receiver返回一个包含着ackno=y+1以及窗口大小的确认帧，这时服务器的Sender和客户端的Receiver达成同步，都将y+1作为整个数据流的初始位置（建立第二条链接）

* **为什么是三次握手，而不是四次？**
答：在第二次握手的时候，服务器的Receiver回应的ackno=x+1，和服务器的Sender发送的seq=y可以合在一个TCP帧里发送，就节省了一次。

* **为什么需要三次握手，而不是两次？**
答：如果client不会向server的确认发出确认，当收到早已失效的报文段后会单方面认为链接已建立而等待发来的数据。

**四次挥手(断开连接)**
![图 2](images/10189db62c7d8512ef0ea00c51170d05580b5d6fbf63e8660f367d67e5a0e5b2.png)  

1. 当客户端Sender的流发完之后，会发送一个包含FIN的TCP帧
2. 服务器的Receiver收到后，回复一个ackno=FIN+1的帧，之后断开客户端Sender和服务器Receiver的连接
3. 同样的当服务器的Sender的流发完之后，会发送一个包含FIN的TCP帧
4. 客户端的Receiver收到后，回复一个ackno=FIN+1的帧，之后断开服务器Sender和客户端Receiver的连接

* 关闭的发起者是可以是任意一方的Sender。TCP是全双工模式，当Client Sender发出FIN=M时，只是代表告诉Server Receiver，Client Sender发送的数据流已经发完了，只是关闭了Client Sender。当Server Receiver收到FIN报文并返回ackno=M+1，表示它已经知道Client Sender没有数据发送了，也只是关闭了Server Receiver，但是Server Sender还是可以发送数据到Client Receiver的，所以并不会立即关闭SOCKET。

* Client Receiver发送完最后的ackno=N+1不能直接进入CLOSED状态，而要保持TIME_WAIT(２MSL, MSL是最长报文段寿命（Maximum Segment Lifetime）)，保证TCP协议的全双工连接能够可靠关闭。当网络原因导致了Server Sender没有收到Client Receiver的ackno=N+1，那么Server Sender就会在超时重传FIN=N，如果此时Client端的连接已经关闭处于CLOESD状态，那么重传的FIN=N就无法得到ack回应，从而导致Server Sender无法关闭。


#### 4. ARP协议(结合CS144)

* ARP 协议实际上负责 IP 地址和 MAC 地址之间的映射，这个映射关系完全由抽象的网络接口`NetworkInterface `自己学习。
* 当`NetworkInterface` 转发 IP 数据报时发现找不到下一跳 IP 地址所对应的以太网地址（查表），就会向网络中广播一个 ARP 请求，并缓存这个数据报直到 ARP 请求得到响应。
* 相对的，如果 `NetworkInterface` 收到了一个 ARP 请求，并且该请求所请求的 IP 地址和自己的对上了，就会向该请求的发送方回传一个 ARP 响应。
* 为了学习网络中 IP-以太网地址的映射关系，NetworkInterface 需要维护一张映射表。而为了适应动态变化的网络拓扑结构，这张映射表肯定需要定时强制更新；表中的每个映射关系最长只能存在一定时间。
* 为了避免频繁的 ARP 请求阻塞网络，我们需要保证一定时间内，相同的 IP 地址的 ARP 请求只发出一次。
* 抽象的网络接口`NetworkInterface `需过滤掉目的以太网地址既不是广播地址（ETHERNET_BROADCAST）、也不是本接口的以太网地址（ehternet_address_）的数据帧。
* 当数据帧的协议是 IPv4 时，且解析成功（`parse()` 返回值为 true），那么就把解析得到的 `InternetDatagram` 数据报推入队列 `datagrams_received_` 中。
* 若数据帧协议为 ARP，且解析成功，那么按照得到的 `ARPMessage` 中的信息，分析是请求本接口的 IP 地址和以太网地址的映射关系、还是响应之前本接口发出的 ARP 请求。如果是 ARP 请求，那么就组装对应的 ARPMessage 并发送给请求发送方；如果是 ARP 响应，那么就将先前缓存的、现在能发送的 IP 数据报全部发送出去。
* 无论是 ARP 请求还是 ARP 响应，只要数据帧解析成功，都要从中学习新的地址映射关系
